# Introduction to Active Record

Active Record is the **M** in the Model-View-Controller (MVC) architecture of Rails. It acts as an Object-Relational Mapper (ORM), which means it provides a bridge between your Ruby code (objects) and the relational database (tables).

## What is an ORM?

An ORM allows you to interact with your database using an object-oriented paradigm. Instead of writing raw SQL queries, you use Ruby methods on your models to perform database operations.

For example, to find a user with a specific ID, instead of:

```sql
SELECT * FROM users WHERE id = 1;
```

You would use Active Record:

```ruby
user = User.find(1)
```

## Why use Active Record?

1.  **Convention over Configuration:** Active Record follows conventions (like naming models based on database tables) that reduce the amount of configuration needed.
2.  **Increased Productivity:** Common database tasks (CRUD operations, associations) are simplified with concise methods.
3.  **Database Agnostic:** While SQLite is the default, Active Record provides a consistent interface regardless of the underlying database (PostgreSQL, MySQL, etc.). You configure the adapter, and your model code remains largely the same.
4.  **Built-in Features:** Active Record comes with powerful features like migrations for schema management, validations for data integrity, and associations for defining relationships between models.
5.  **Integration with Rails:** Active Record is tightly integrated with the rest of the Rails framework, working seamlessly with controllers for handling requests and views for displaying data.

## How it Works (Simplified)

*   **Models:** You define Ruby classes that inherit from `ApplicationRecord`. By convention, a model named `User` will correspond to a database table named `users`.
*   **Attributes:** Columns in your database table become attributes of your model objects. You can access and modify them like regular object attributes.
    ```ruby
    user = User.new
    user.name = "John Doe"
    user.save
    puts user.id # Accessing the id attribute after saving
    ```
*   **Methods:** Active Record provides a rich set of class and instance methods for querying, creating, updating, and deleting data.

In the following sections, we will dive deeper into the specific features and syntax of Active Record, starting with Migrations.

# Migrations Theory

Database migrations in Rails are a way to version control your database schema. Instead of writing SQL files directly, you use Ruby files to define changes to your database. This makes it easy to track changes, collaborate with others, and move your application between different environments (development, test, production).

## Key Concepts

*   **Migration Files:** These are Ruby files generated by Rails that contain instructions for modifying your database schema. Each file represents a single set of changes.
*   **`change` Method:** The primary method in a migration. Rails attempts to automatically determine how to reverse the changes defined in the `change` method when rolling back a migration.
*   **`up` and `down` Methods:** In older migrations or for more complex changes that cannot be automatically reversed, you might use separate `up` (for applying the change) and `down` (for reversing the change) methods.
*   **Schema.rb:** Rails maintains a `schema.rb` file that represents the current state of your database schema. This file is automatically updated when you run migrations.
*   **Timestamp:** Each migration file is prefixed with a timestamp (e.g., `20231026120000_create_articles.rb`). This timestamp determines the order in which migrations are applied.

## Why Use Migrations?

*   **Version Control:** Track changes to your database schema alongside your application code.
*   **Collaboration:** Easily share database changes with other developers.
*   **Environment Consistency:** Ensure your database schema is the same across different environments.
*   **Rollbacks:** Easily undo database changes if needed.
*   **Database Agnostic:** Use the same migration syntax regardless of your underlying database (as long as there's an Active Record adapter for it).

## Generating Migrations

You typically generate migration files using Rails generator commands:

```bash
rails generate migration CreateArticles table_name
rails generate migration AddColumnToUsers column_name:data_type
```

These commands create a migration file with a basic structure for creating a table or adding a column, respectively.

## Running Migrations

You use rake tasks (or `rails db:` commands in newer Rails versions) to run migrations:

```bash
rails db:migrate       # Run pending migrations
rails db:rollback      # Rollback the last migration
rails db:reset         # Drop the database and recreate it from schema.rb
rails db:setup         # Run db:create, db:schema:load, and db:seed
```

Migrations are a fundamental part of Rails development, allowing you to evolve your database schema in a structured and manageable way. The next section will cover the syntax used within migration files with examples.

# Defining Models Theory

In Rails, models are Ruby classes that inherit from `ApplicationRecord`. Each model typically corresponds to a table in your database, with the model name being the singular form and the table name being the plural form (e.g., `Article` model corresponds to the `articles` table).

Models are the **M** in MVC and are responsible for:

*   **Interacting with the database:** Using Active Record methods to perform CRUD operations (Create, Read, Update, Delete).
*   **Defining associations:** Specifying relationships between different models (e.g., a `User` has many `Articles`).
*   **Implementing validations:** Ensuring data integrity by adding constraints on attributes.
*   **Defining callbacks:** Executing code at specific points in the model's lifecycle (e.g., before saving, after destroying).
*   **Implementing business logic:** Adding methods related to the data the model represents.

## How Models Map to Database Tables

Active Record uses **convention over configuration** to automatically map model attributes to database table columns. When you create a model, Rails expects a corresponding table with columns that match the model's attributes.

For example, if you have an `Article` model, Active Record will look for an `articles` table in your database. The columns in the `articles` table (e.g., `title`, `body`, `created_at`, `updated_at`) will be accessible as attributes on an `Article` object.

## `ApplicationRecord`

All models in a Rails application inherit from `ApplicationRecord`. This class itself inherits from `ActiveRecord::Base` and serves as a central place to define shared functionality, configurations, or concerns for all your models.

```ruby
# app/models/application_record.rb
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end
```

Your individual models will then inherit from `ApplicationRecord`:

```ruby
# app/models/article.rb
class Article < ApplicationRecord
  # Model logic goes here
end
```

Understanding how to define and utilize models is crucial for working with data in Rails applications. The next section will provide syntax examples for common model definitions and configurations.

# CRUD Operations Theory

CRUD stands for Create, Read, Update, and Delete. These are the four basic functions of persistent storage, and Active Record provides simple methods to perform them on your model objects.

## Create

Creating new records in the database involves instantiating a new model object and saving it. You can do this in a few ways:

*   **`new` and `save`:** Create an object in memory and then save it to the database.
    ```ruby
    article = Article.new(title: "My First Article", body: "This is the content.")
    article.save
    # Returns true if saved successfully, false otherwise
    ```
*   **`create`:** Instantiate and save the object in one step.
    ```ruby
    article = Article.create(title: "Another Article", body: "More content.")
    # Returns the object whether it was saved successfully or not. Raises an exception if validations fail (with `create!`)
    ```

## Read

Reading records from the database involves querying the database using class methods provided by Active Record.

*   **`all`:** Retrieve all records from a table.
    ```ruby
    articles = Article.all
    ```
*   **`find`:** Retrieve a single record by its primary key (usually `id`).
    ```ruby
    article = Article.find(1)
    ```
*   **`find_by`:** Retrieve the first record that matches specific conditions.
    ```ruby
    article = Article.find_by(title: "My First Article")
    ```
*   **`where`:** Retrieve all records that match specific conditions. Returns an Active Record Relation, which can be further chained.
    ```ruby
    articles = Article.where(status: "published")
    ```
*   **`first`, `last`, `limit`, `order`:** Methods for retrieving specific records or ordering the results.
    ```ruby
    latest_article = Article.last
    recent_articles = Article.order(created_at: :desc).limit(10)
    ```

## Update

Updating existing records involves finding the record, changing its attributes, and saving the changes.

*   **Modify and `save`:**
    ```ruby
    article = Article.find(1)
    article.title = "Updated Title"
    article.save
    ```
*   **`update`:** Update attributes and save in one step.
    ```ruby
    article = Article.find(1)
    article.update(body: "Updated content.")
    # Returns true if updated successfully, false otherwise. Raises an exception if validations fail (with `update!`).
    ```
*   **`update_all`:** Update multiple records at once without instantiating them.
    ```ruby
    Article.where(status: "draft").update_all(status: "archived")
    ```

## Delete

Deleting records involves finding the record and destroying it.

*   **`destroy`:** Delete a single record. Runs callbacks.
    ```ruby
    article = Article.find(1)
    article.destroy
    ```
*   **`delete`:** Delete a single record without running callbacks.
    ```ruby
    article = Article.find(1)
    article.delete
    ```
*   **`destroy_all`:** Delete multiple records and run callbacks for each.
    ```ruby
    Article.where(status: "archived").destroy_all
    ```
*   **`delete_all`:** Delete multiple records without running callbacks.
    ```ruby
    Article.where(status: "archived").delete_all
    ```

Understanding these CRUD operations is fundamental to managing data with Active Record. The next section will provide syntax examples for these operations.

# Validations Theory

Validations in Active Record are used to ensure that data is valid before it is saved to the database. This helps maintain data integrity and prevents incorrect or incomplete data from being stored.

Validations are typically defined in your model classes using various helper methods.

## How Validations Work

When you attempt to save an object (`save`, `create`, `update`), Active Record runs the validations defined in the model. If any validation fails, the save operation is cancelled, and the method returns `false`. The errors that occurred are available in the `errors` object of the model instance.

Methods that end with `!` (like `save!`, `create!`, `update!`) will raise an `ActiveRecord::RecordInvalid` exception if validations fail.

## Why Use Validations?

*   **Data Integrity:** Prevent invalid data from being written to the database.
*   **Business Logic:** Enforce business rules related to data format, presence, uniqueness, etc.
*   **User Feedback:** Provide meaningful error messages to users when they submit invalid data (often used in conjunction with forms and controllers).
*   **Database Independence:** Define validation rules in your models, making them independent of the specific database system being used.

## Where to Define Validations

Validations are defined within the model class using methods like `validates` or specific helper methods.

```ruby
class Article < ApplicationRecord
  validates :title, presence: true
  validates :body, length: { minimum: 10 }
end
```

## Common Validation Helpers

Rails provides many built-in validation helpers:

*   `presence`: Ensures that a specific attribute is not empty.
*   `uniqueness`: Checks if the value of an attribute is unique across all records in the table.
*   `length`: Validates the length of a string or array.
*   `numericality`: Validates that an attribute is a number.
*   `inclusion`: Validates that an attribute's value is in a given set.
*   `exclusion`: Validates that an attribute's value is not in a given set.
*   `format`: Validates the format of an attribute using a regular expression.
*   ` संबंध` (`belongs_to`, `has_one`, `has_many`): Can automatically add presence validation for `belongs_to` associations.

## Custom Validations

If the built-in helpers are not sufficient, you can define custom validation methods or custom validators.

```ruby
class Article < ApplicationRecord
  validate :starts_with_a

  private

  def starts_with_a
    unless title.starts_with?('A')
      errors.add(:title, "must start with 'A'")
    end
  end
end
```

Validations are a critical part of building robust Rails applications. They ensure that the data you work with is reliable and conforms to your application's rules. The next section will provide syntax examples for using various validation helpers.

# Callbacks Theory

Active Record callbacks are methods that get triggered at certain moments of an object's life cycle. They allow you to attach code that will run automatically when an object is created, updated, destroyed, validated, or saved.

## What are Callbacks?

Callbacks are hooks into the Active Record object life cycle. When you call methods like `create`, `save`, `update`, or `destroy` on an Active Record object, a series of callbacks are executed.

For example, when creating an object:

1.  `before_validation`
2.  `after_validation`
3.  `before_save`
4.  `before_create`
5.  Database INSERT operation
6.  `after_create`
7.  `after_save`
8.  `after_commit` or `after_rollback`

Understanding the order of these callbacks is important for writing code that interacts correctly with the object's state at each stage.

## Defining Callbacks

You define callbacks in your model classes using specific helper methods, followed by the name of a method to run, a `Proc`, or a block.

```ruby
class Article < ApplicationRecord
  before_save :set_published_at
  after_destroy :log_deletion

  private

  def set_published_at
    # Code to run before saving
  end

  def log_deletion
    # Code to run after destroying
  end
end
```

## Available Callbacks

Active Record provides a comprehensive list of callbacks:

**Creation:**

*   `before_validation`
*   `after_validation`
*   `before_save`
*   `before_create`
*   `after_create`
*   `after_save`
*   `after_commit`/`after_rollback`

**Updating:**

*   `before_validation`
*   `after_validation`
*   `before_save`
*   `before_update`
*   `after_update`
*   `after_save`
*   `after_commit`/`after_rollback`

**Destruction:**

*   `before_destroy`
*   `after_destroy`
*   `after_commit`/`after_rollback`

**Other Callbacks:**

*   `after_initialize`: Called when an object is instantiated by Active Record (either when loading from the database or creating a new object).
*   `after_find`: Called when an object is loaded from the database.

## Conditional Callbacks

You can make callbacks conditional using `:if`, `:unless`, `:on`, or `:债` options.

```ruby
class Article < ApplicationRecord
  before_save :set_published_at, if: :published?
  after_save :send_notification, on: :create
end
```

Callbacks are useful for automating tasks and enforcing business logic at specific points in the object's life cycle. However, it's important to use them judiciously to keep your code easy to understand and debug. The next section will provide syntax examples for using various callbacks.

# Querying the Database Theory

Active Record provides a rich query interface that allows you to retrieve data from your database using Ruby methods. These methods return `ActiveRecord::Relation` objects, which represent a collection of records and can be chained together to build complex queries.

## Returning Objects vs. Relations

*   **Methods that return a single object:** Methods like `find`, `find_by`, `first`, `last` return a single model instance (or `nil` if not found, for `find_by`, `first`, `last`).
    ```ruby
    article = Article.find(1)
    latest_article = Article.last
    ```
*   **Methods that return an `ActiveRecord::Relation`:** Most querying methods, like `all`, `where`, `order`, `limit`, `select`, return an `ActiveRecord::Relation`. This is an object that represents the query but hasn't been executed yet. You can chain additional query methods onto a Relation.
    ```ruby
    published_articles = Article.where(status: "published") # Returns a Relation
    recent_published = published_articles.order(created_at: :desc).limit(5) # Returns a new Relation
    ```

The database query is only executed when you actually need to access the data from the Relation (e.g., iterating over it, calling `.to_a`, `.count`, etc.). This is known as **lazy loading** and helps optimize performance.

## Common Query Methods

*   **`all`:** Retrieves all records from the table.
    ```ruby
    articles = Article.all
    ```
*   **`where`:** Specifies conditions for the query. Can take a hash, an array, or a string.
    ```ruby
    Article.where(status: "published", category: "Technology")
    Article.where("views > ?", 100)
    ```
*   **`order`:** Specifies the order of the results.
    ```ruby
    Article.order(:title) # ASC order
    Article.order(created_at: :desc) # DESC order
    Article.order(status: :asc, created_at: :desc)
    ```
*   **`limit` and `offset`:** Limit the number of records returned and skip a certain number of records.
    ```ruby
    Article.limit(10)
    Article.limit(10).offset(20)
    ```
*   **`select`:** Selects specific columns instead of all columns.
    ```ruby
    Article.select(:id, :title)
    ```
*   **`joins`:** Performs a SQL JOIN to eager load associated records or query based on associated data.
    ```ruby
    Article.joins(:user).where(users: { country: "USA" })
    ```
*   **`includes`:** Eager loads associated records to avoid N+1 query problems. Use this when you plan to access associated records for each object in the collection.
    ```ruby
    articles = Article.includes(:user) # Fetch articles and their associated users in one or two queries
    articles.each do |article|
      puts article.user.name # Accessing user doesn't trigger a new query for each article
    end
    ```

## Querying Associations

You can also query through associations defined in your models.

```ruby
user = User.find(1)
user.articles.where(status: "draft") # Find draft articles belonging to this user
```

Active Record's querying capabilities are extensive. These are just the basics to get you started. The next section will provide syntax examples for building various types of queries.

# Advanced Active Record Concepts Theory

Beyond the fundamental CRUD operations, associations, validations, callbacks, and querying, Active Record offers several advanced features that are crucial for building robust, scalable, and performant applications. This section introduces some of these concepts.

## Transactions

Transactions are used to group database operations into a single atomic unit. If any operation within a transaction fails, all the changes made within that transaction are rolled back. This ensures data integrity, especially when performing multiple related database operations.

```ruby
# Begin a transaction
ActiveRecord::Base.transaction do
  user = User.create!(name: "John Doe")
  user.articles.create!(title: "Transaction Article", body: "Content.")
  # If any of the above lines raise an exception, the entire transaction is rolled back.
end # The transaction is committed if no exception is raised.

# Using a block is the most common and recommended way
begin
  ActiveRecord::Base.transaction do
    order = Order.create!(total: 100)
    product = Product.find(1)
    product.update!(stock: product.stock - 1)
    # If stock update fails, order creation is also rolled back
  end
rescue ActiveRecord::RecordInvalid => e
  puts "Transaction failed: #{e.message}"
end
```

Transactions are essential for operations that require multiple dependent database changes.

## Locking

Locking is used to manage concurrent access to database records, preventing race conditions when multiple processes or threads might try to modify the same data simultaneously. Active Record supports different types of locking:

### Optimistic Locking

Optimistic locking assumes that conflicts are rare. It works by adding a `lock_version` column to the table. When a record is updated, the `lock_version` is incremented. If a record is updated by another process with an older `lock_version`, an `ActiveRecord::StaleObjectError` is raised.

```ruby
class Article < ApplicationRecord
  # Assumes a lock_version integer column exists in the articles table
end

article = Article.find(1)
article2 = Article.find(1)

article.update(title: "Update 1") # lock_version increments

# This will raise ActiveRecord::StaleObjectError because article2 has the old lock_version
article2.update(title: "Update 2")
```

You typically handle `ActiveRecord::StaleObjectError` by re-fetching the record, merging changes, and retrying the update.

### Pessimistic Locking

Pessimistic locking assumes that conflicts are likely and obtains a lock on the record(s) before performing any operations. This prevents other processes from reading or writing the locked records until the lock is released (usually at the end of a transaction).

```ruby
# Lock a single record within a transaction
Article.transaction do
  article = Article.lock.find(1)
  article.increment!(:views)
end

# Lock multiple records
articles = Article.where(status: "draft").lock
articles.each do |article|
  article.update!(status: "pending")
end
```
Pessimistic locking can impact performance as it makes processes wait, so use it only when necessary.

## Explaining Queries

Understanding how Active Record translates your Ruby queries into SQL and how the database executes that SQL is vital for performance tuning. The `explain` method can show you the query execution plan.

```ruby
puts Article.where(status: "published").includes(:user).explain
```
The output of `explain` varies depending on the database adapter but provides insights into index usage, join methods, and overall query cost.

## Connection Handling

Active Record manages database connections, typically using a connection pool. Understanding connection pooling, threading issues, and how to manage connections in complex scenarios (like background jobs) is important for performance and stability.

These advanced concepts are not always needed for simple applications but become increasingly important as your application grows in complexity and traffic. Referencing the official Rails Guides for in-depth documentation on these topics is highly recommended. 